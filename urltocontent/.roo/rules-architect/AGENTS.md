# Project Architecture Rules (Non-Obvious Only)

## 新功能：方向选择机制架构

### 核心设计原则
- **方向即文档**：每个方向在飞书知识库中对应一个文档（obj_type: docx）
- **自动检查创建**：写入前自动检查文档是否存在，不存在则创建
- **三层降级**：内置方向 → 自定义方向 → 默认方向（自动总结）
- **用户反馈**：必须向用户反馈最终写入的文档名称

### 架构影响

#### 前端架构变更
- 在 URL 解析成功后新增方向选择界面
- 状态管理增加：`selectedDirection`（已选方向）、`customDirection`（自定义方向）
- 用户交互流程：解析成功 → 选择方向 → 确认写入 → 显示结果

#### 后端架构变更
- API 扩展：`/api/write` 请求添加 `direction` 字段
- FeishuService 新增方法：`FindOrCreateDocument(direction)` - 查找或创建方向文档
- 响应扩展：添加 `documentName` 字段返回最终写入的文档名称

#### 数据流变更
1. 用户选择方向（或自定义）
2. POST /api/write 携带 direction 参数
3. Handler → FeishuService.FindOrCreateDocument(direction)
4. 检查知识库根目录下是否存在该方向的文档
5. 不存在则创建（CreateDocument），存在则返回 token
6. 将内容写入文档
7. 返回 documentName 和 documentID
8. 前端显示写入成功及文档名称

### 技术挑战

#### 文档查找
- 必须遍历知识库根目录下的所有节点
- 通过标题匹配查找方向文档（page_size 最大 50）
- 需要处理分页（has_more, page_token）

#### 并发安全
- 多个用户同时使用同一方向可能导致文档重复创建
- 当前无锁机制，依赖飞书 API 的幂等性
- 建议：添加分布式锁或数据库去重

#### 性能优化
- 每次写入都检查文档存在性，有性能开销
- 建议：在服务启动时缓存所有方向文档的 token
- 缓存失效：定期刷新或用户手动触发

### 扩展性考虑

#### 方向管理
- 当前内置方向硬编码在前端（技术、成长、生活）
- 建议：将内置方向配置化，存储在配置文件或数据库
- 未来支持动态添加/删除方向

#### 文档组织
- 当前所有方向文档都在知识库根目录
- 建议：创建一个"方向目录"文档，所有方向文档作为其子节点
- 但飞书 API 限制无法创建真实文件夹

## 架构约束

### 飞书 API 限制
- **关键约束**：飞书 Wiki API 不支持直接创建文件夹节点
- 只能创建 `obj_type: "docx"` 的文档类型
- 所有文档必须创建在知识库根目录下
- 无法实现层级文件夹结构（所有文档平铺在根目录）

### 通信架构
- 无消息队列、无 WebSocket、无事件总线
- 纯 HTTP 请求/响应模式
- 前端主动轮询后端（每 30 秒健康检查）
- 后端无主动推送能力

### 隐藏的架构决策

#### URL 解析服务（ParserService）
- 超时硬编码 60 秒（services/parser.go:19）
- 使用浏览器 User-Agent 模拟真实请求
- 无代理服务，直接请求目标 URL
- 解析逻辑：字符串匹配提取标题、描述、段落

#### 飞书服务（FeishuService）
- 租户访问令牌无缓存（每次请求都重新获取）
- HTTP 客户端超时 30 秒（services/feishu.go:91）
- 文档内容分块写入（批量创建块）
- 文档 token 缓存在服务实例中（summaryFolderToken）

## 组件耦合

### Handler 层
- Handler 依赖 Config、ParserService、FeishuService
- CORSMiddleware 包装所有路由处理器
- 无依赖注入框架，硬编码构造

### Service 层
- ParserService：独立，无外部依赖
- FeishuService：依赖飞书凭证和 Wiki ID
- 服务间无通信，独立运行

### 前端组件
- 单组件架构（App.jsx 410 行）
- 无组件拆分，所有逻辑集中
- 无共享状态库，纯本地状态管理

## 扩展性限制

### 后端扩展
- 无数据库层，无数据持久化
- 无用户认证，无权限控制
- 配置硬编码，修改需重启服务
- 日志无结构化，难以追踪和分析

### 前端扩展
- 无路由，无法多页面
- 无状态管理，难以共享数据
- API 地址硬编码，环境切换需修改代码
- 无错误边界，错误处理分散

## 性能瓶颈

### 后端性能
- ParserService 超时 60 秒：慢速网页会导致请求阻塞
- 飞书 API 超时 30 秒：网络问题会导致请求失败
- 无并发控制，单 goroutine 处理请求
- 无连接池，每次 HTTP 请求新建连接

### 前端性能
- 每 30 秒轮询后端健康状态
- 无请求缓存，重复请求相同 URL
- 无代码分割，首屏加载全部代码
- 无虚拟滚动，大量消息会导致性能问题

## 安全考虑

### CORS 配置
- 后端允许所有来源（`Access-Control-Allow-Origin: *`）
- 生产环境有安全风险（CSRF 攻击）
- 需要根据部署环境配置允许的来源

### 凭证管理
- 飞书凭证硬编码在 `config.go`
- 无密钥加密存储
- 测试文件包含实际凭证（feishu_test.go）

### 输入验证
- 前端 URL 验证：仅使用 `new URL()` 抛错
- 后端无输入长度限制
- 无 XSS 防护（依赖飞书 API 处理）

## 数据流

### URL 解析流程
1. 用户输入 URL → 前端验证
2. POST /api/parse → 后端接收
3. Handler → ParserService.ParseURL
4. 直接请求目标 URL（60 秒超时）
5. 字符串匹配提取 HTML 内容
6. 返回解析结果 → 前端显示

### 飞书写入流程
1. 用户确认 → 前端 POST /api/write
2. Handler → FeishuService.CreateDocument
3. 获取租户访问令牌（每次重新获取）
4. 查找或创建"自动总结"文档（实际是文档，非文件夹）
5. 批量创建内容块
6. 返回文档 ID → 前端显示

## 部署架构

### 单体架构
- 前后端分离但无服务网格
- 后端单进程运行，无负载均衡
- 无容器化配置（Dockerfile）
- 无 CI/CD 流程

### 依赖管理
- Go：无外部依赖（仅标准库）
- React：仅 Vite 和 React，无复杂依赖
- 无 API 网关，直接暴露后端端口

## 监控和可观测性

### 日志系统
- 后端：使用 `fmt.Println` 输出到标准输出
- 前端：使用 `console.log` 输出到浏览器控制台
- 无日志聚合、无结构化日志
- 无指标收集、无追踪系统

### 健康检查
- 后端：/health 端点返回静态状态
- 前端：每 30 秒轮询后端
- 无分布式追踪、无错误监控

## 未来扩展建议

### 后端
- 添加数据库持久化（PostgreSQL/MySQL）
- 引入消息队列（Redis/RabbitMQ）
- 实现缓存层（Redis）
- 添加结构化日志（logrus/zap）
- 实现配置中心（环境变量/配置文件）

### 前端
- 添加路由（React Router）
- 引入状态管理（Zustand/Redux）
- 实现代码分割
- 添加错误边界
- 实现请求缓存

### 架构
- 考虑微服务拆分
- 引入 API 网关
- 实现服务网格
- 添加监控和告警